This is a squashed patch from various patches sent upstream.  Full write-up

   https://www.openwall.com/lists/oss-security/2019/01/23/5

--- ghostscript-9.26/psi/interp.c	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/psi/interp.c	2019-01-23 18:48:55.017067402 +0000
@@ -703,7 +703,7 @@
                  * i.e. it's an internal operator we have hidden
                  */
                 code = dict_find_string(systemdict, (const char *)bufptr, &tobj);
-                if (code < 0) {
+                if (code <= 0) {
                     buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';
                     rlen += 4;
                     bufptr = buf;
@@ -761,6 +761,7 @@
     uint size = ref_stack_count(pstack) - skip;
     uint save_space = ialloc_space(idmemory);
     int code, i;
+    ref *safety, *safe;
 
     if (size > 65535)
         size = 65535;
@@ -778,6 +779,13 @@
                 make_null(&arr->value.refs[i]);
         }
     }
+    if (pstack == &o_stack && dict_find_string(systemdict, "SAFETY", &safety) > 0 &&
+        dict_find_string(safety, "safe", &safe) > 0 && r_has_type(safe, t_boolean) &&
+        safe->value.boolval == true) {
+        code = ref_stack_array_sanitize(i_ctx_p, arr, arr);
+        if (code < 0)
+            return code;
+    }
     ialloc_set_space(idmemory, save_space);
     return code;
 }
--- ghostscript-9.26/psi/int.mak	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/psi/int.mak	2019-01-23 18:48:44.616067402 +0000
@@ -204,7 +204,8 @@
 $(PSOBJ)istack.$(OBJ) : $(PSSRC)istack.c $(GH) $(memory__h)\
  $(ierrors_h) $(gsstruct_h) $(gsutil_h)\
  $(ialloc_h) $(istack_h) $(istkparm_h) $(istruct_h) $(iutil_h) $(ivmspace_h)\
- $(store_h) $(INT_MAK) $(MAKEDIRS)
+ $(store_h) $(icstate_h) $(iname_h) $(dstack_h) $(idict_h) \
+ $(INT_MAK) $(MAKEDIRS)
 	$(PSCC) $(PSO_)istack.$(OBJ) $(C_) $(PSSRC)istack.c
 
 $(PSOBJ)iutil.$(OBJ) : $(PSSRC)iutil.c $(GH) $(math__h) $(memory__h) $(string__h)\
--- ghostscript-9.26/psi/istack.c	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/psi/istack.c	2019-01-23 18:48:44.616067402 +0000
@@ -27,6 +27,10 @@
 #include "iutil.h"
 #include "ivmspace.h"		/* for local/global test */
 #include "store.h"
+#include "icstate.h"
+#include "iname.h"
+#include "dstack.h"
+#include "idict.h"
 
 /* Forward references */
 static void init_block(ref_stack_t *pstack, const ref *pblock_array,
@@ -294,6 +298,80 @@
     return 0;
 }
 
+int
+ref_stack_array_sanitize(i_ctx_t *i_ctx_p, ref *sarr, ref *darr)
+{
+    int i, code;
+    ref obj, arr2;
+    ref *pobj2;
+    gs_memory_t *mem = (gs_memory_t *)idmemory->current;
+
+    if (!r_is_array(sarr) || !r_has_type(darr, t_array))
+        return_error(gs_error_typecheck);
+
+    for (i = 0; i < r_size(sarr); i++) {
+        code = array_get(mem, sarr, i, &obj);
+        if (code < 0)
+            make_null(&obj);
+        switch(r_type(&obj)) {
+          case t_operator:
+          {
+            int index = op_index(&obj);
+
+            if (index > 0 && index < op_def_count) {
+                const byte *data = (const byte *)(op_index_def(index)->oname + 1);
+                if (dict_find_string(systemdict, (const char *)data, &pobj2) <= 0) {
+                    byte *s = gs_alloc_bytes(mem, strlen((char *)data) + 5, "ref_stack_array_sanitize");
+                    if (s) {
+                        s[0] =  '\0';
+                        strcpy((char *)s, "--");
+                        strcpy((char *)s + 2, (char *)data);
+                        strcpy((char *)s + strlen((char *)data) + 2, "--");
+                    }
+                    else {
+                        s = (byte *)data;
+                    }
+                    code = name_ref(imemory, s, strlen((char *)s), &obj, 1);
+                    if (code < 0) make_null(&obj);
+                    if (s != data)
+                        gs_free_object(mem, s, "ref_stack_array_sanitize");
+                }
+            }
+            else {
+                make_null(&obj);
+            }
+            ref_assign(darr->value.refs + i, &obj);
+            break;
+          }
+          case t_array:
+          case t_shortarray:
+          case t_mixedarray:
+          {
+            int attrs = r_type_attrs(&obj) & (a_write | a_read | a_execute | a_executable);
+            /* We only want to copy executable arrays */
+            if (attrs & (a_execute | a_executable)) {
+                code = ialloc_ref_array(&arr2, attrs, r_size(&obj), "ref_stack_array_sanitize");
+                if (code < 0) {
+                    make_null(&arr2);
+                }
+                else {
+                    code = ref_stack_array_sanitize(i_ctx_p, &obj, &arr2);
+                }
+                ref_assign(darr->value.refs + i, &arr2);
+            }
+            else {
+                ref_assign(darr->value.refs + i, &obj);
+            }
+            break;
+          }
+          default:
+            ref_assign(darr->value.refs + i, &obj);
+        }
+    }
+    return 0;
+}
+
+
 /*
  * Store the top 'count' elements of a stack, starting 'skip' elements below
  * the top, into an array, with or without store/undo checking.  age=-1 for
--- ghostscript-9.26/psi/istack.h	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/psi/istack.h	2019-01-23 18:48:44.616067402 +0000
@@ -129,6 +129,9 @@
                     uint skip, int age, bool check,
                     gs_dual_memory_t *idmem, client_name_t cname);
 
+int
+ref_stack_array_sanitize(i_ctx_t *i_ctx_p, ref *sarr, ref *darr);
+
 /*
  * Pop the top N elements off a stack.
  * The number must not exceed the number of elements in use.
--- ghostscript-9.26/Resource/Init/gs_diskn.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_diskn.ps	2019-01-23 18:48:50.999067402 +0000
@@ -51,7 +51,7 @@
     mark 5 1 roll ] mark exch { { } forall } forall ]
     //systemdict /.searchabledevs 2 index .forceput
     exch .setglobal
-  }
+  } executeonly
   if
 } .bind executeonly odef % must be bound and hidden for .forceput
 
--- ghostscript-9.26/Resource/Init/gs_dps1.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_dps1.ps	2019-01-23 18:49:06.344067402 +0000
@@ -33,14 +33,17 @@
 
 /SharedFontDirectory .FontDirectory .gcheck
  { .currentglobal //false .setglobal
+   currentdict
    /LocalFontDirectory .FontDirectory dup maxlength dict copy
-   .forcedef	% LocalFontDirectory is local, systemdict is global
+   .forceput	% LocalFontDirectory is local, systemdict is global
    .setglobal .FontDirectory
- }
- { /LocalFontDirectory .FontDirectory
-   .forcedef	% LocalFontDirectory is local, systemdict is global
+ } executeonly
+ {
+   currentdict
+   /LocalFontDirectory .FontDirectory
+   .forceput	% LocalFontDirectory is local, systemdict is global
    50 dict
- }
+ }executeonly
 ifelse def
 
 end				% systemdict
@@ -55,7 +58,7 @@
     { //SharedFontDirectory }
     { /LocalFontDirectory .systemvar }	% can't embed ref to local VM
    ifelse .forceput pop	% LocalFontDirectory is local, systemdict is global
- } .bind odef
+ } .bind executeonly odef
 % Don't just copy (load) the definition of .setglobal:
 % it gets redefined for LL3.
 /setshared { /.setglobal .systemvar exec } odef
@@ -67,25 +70,26 @@
 
 /selectfont		% <fontname> <size> selectfont -
  {
-   { 1 .argindex findfont
+   {
+     1 .argindex findfont
      1 index dup type /arraytype eq { makefont } { scalefont } ifelse
      setfont pop pop
    } stopped { /selectfont .systemvar $error /errorname get signalerror } if
  } odef
 % undefinefont has to take local/global VM into account.
 /undefinefont		% <fontname> undefinefont -
- { .FontDirectory 1 .argindex .forceundef	% FontDirectory is readonly
+ { //.FontDirectory 1 .argindex .forceundef	% FontDirectory is readonly
    .currentglobal
     {		% Current mode is global; delete from local directory too.
       //systemdict /LocalFontDirectory .knownget
-       { 1 index .forceundef }		% LocalFontDirectory is readonly
+       { 1 index .forceundef } executeonly		% LocalFontDirectory is readonly
       if
     }
     {		% Current mode is local; if there was a shadowed global
                 % definition, copy it into the local directory.
       //systemdict /SharedFontDirectory .knownget
        { 1 index .knownget
-          { .FontDirectory 2 index 3 -1 roll { put } systemdict /superexec known {//superexec}{1183615869 internaldict /superexec get exec} ifelse } % readonly
+          { //.FontDirectory 2 index 3 -1 roll { put } systemdict /superexec known {//superexec}{1183615869 internaldict /superexec get exec} ifelse } % readonly
          if
        }
       if
@@ -126,7 +130,7 @@
           }
          ifelse
        } forall
-      pop counttomark 2 idiv { .forceundef } repeat pop		% readonly
+      pop counttomark 2 idiv { .forceundef } executeonly repeat pop		% readonly
     }
    if
    //SharedFontDirectory exch .forcecopynew pop
--- ghostscript-9.26/Resource/Init/gs_fntem.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_fntem.ps	2019-01-23 18:48:50.999067402 +0000
@@ -401,12 +401,12 @@
       .forceput % FontInfo can be read-only.
       pop                                                        % bool <font>
       exit
-    } if
+    } executeonly if
     dup /FontInfo get                                            % bool <font> <FI>
     /GlyphNames2Unicode /Unicode /Decoding findresource
     .forceput % FontInfo can be read-only.
     exit
-  } loop
+  } executeonly loop
   exch setglobal
 } .bind executeonly odef % must be bound and hidden for .forceput
 
--- ghostscript-9.26/Resource/Init/gs_fonts.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_fonts.ps	2019-01-23 18:51:29.325067402 +0000
@@ -100,7 +100,7 @@
        { 2 index token not
           { (Fontmap entry for ) print 1 index =only
             ( ends prematurely!  Giving up.) = flush
-            {.loadFontmap} 0 get 1 .quit
+            {//.loadFontmap exec} 0 get 1 .quit
           } if
          dup /; eq { pop 3 index 3 1 roll .growput exit } if
          pop
@@ -202,6 +202,14 @@
  { pop }
  { /FONTPATH (GS_FONTPATH) getenv not { () } if def }
 ifelse
+
+% The following are dummy definitions that, if we have a FONTPATH, will
+% be replaced in the following section.
+% They are here so immediately evaulation will work, and allow them to
+% undefined at the bottom of the file.
+/.scanfontbegin{} bind def
+/.scanfontdir {} bind def
+
 FONTPATH length 0 eq { (%END FONTPATH) .skipeof } if
 /FONTPATH [ FONTPATH .pathlist ] def
 
@@ -242,12 +250,12 @@
 /.scanfontbegin
  {      % Construct the table of all file names already in Fontmap.
    currentglobal //true setglobal
-   .scanfontdict dup maxlength Fontmap length 2 add .max .setmaxlength
+   //.scanfontdict dup maxlength Fontmap length 2 add .max .setmaxlength
    Fontmap
     { exch pop
        { dup type /stringtype eq
-          { .splitfilename pop .fonttempstring copy .lowerstring cvn
-            .scanfontdict exch //true put
+          { //.splitfilename exec pop //.fonttempstring copy //.lowerstring exec cvn
+            //.scanfontdict exch //true put
           }
           { pop
           }
@@ -280,9 +288,9 @@
   /txt //true
 .dicttomark def
 /.scan1fontstring 8192 string def
-% %%BeginFont: is not per Adobe documentation, but a few fonts have it.
+% BeginFont: is not per Adobe documentation, but a few fonts have it.
 /.scanfontheaders [(%!PS-Adobe*) (%!FontType*) (%%BeginFont:*)] def
-0 .scanfontheaders { length .max } forall 6 add % extra for PFB header
+0 //.scanfontheaders { length .max } forall 6 add % extra for PFB header
 /.scan1fontfirst exch string def
 /.scanfontdir           % <dirname> .scanfontdir -
  { currentglobal exch //true setglobal
@@ -291,10 +299,10 @@
    0 0 0 4 -1 roll      % found scanned files
     {           % stack: <fontcount> <scancount> <filecount> <filename>
       exch 1 add exch                   % increment filecount
-      dup .splitfilename .fonttempstring copy .lowerstring
+      dup //.splitfilename exec //.fonttempstring copy //.lowerstring exec
                 % stack: <fontcount> <scancount> <filecount+1> <filename>
                 %       <BASE> <ext>
-      .scanfontskip exch known exch .scanfontdict exch known or
+      //.scanfontskip exch known exch //.scanfontdict exch known or
        { pop
                 % stack: <fontcount> <scancount> <filecount+1>
        }
@@ -309,7 +317,7 @@
                 % On some platforms, the file operator will open directories,
                 % but an error will occur if we try to read from one.
                 % Handle this possibility here.
-            dup .scan1fontfirst { readstring } .internalstopped
+            dup //.scan1fontfirst { readstring } .internalstopped
              { pop pop () }
              { pop }
             ifelse
@@ -322,7 +330,7 @@
           { dup length 6 sub 6 exch getinterval }
          if
                 % Check for font file headers.
-         //false .scanfontheaders
+         //false //.scanfontheaders
           { 2 index exch .stringmatch or
           }
          forall exch pop
@@ -335,7 +343,7 @@
                 { exch copystring exch
                   DEBUG { ( ) print dup =only flush } if
                   1 index .definenativefontmap
-                  .splitfilename pop //true .scanfontdict 3 1 roll .growput
+                  //.splitfilename exec pop //true //.scanfontdict 3 1 roll .growput
                         % Increment fontcount.
                   3 -1 roll 1 add 3 1 roll
                 }
@@ -352,7 +360,7 @@
        }
       ifelse
     }
-   .scan1fontstring filenameforall
+   //.scan1fontstring filenameforall
    QUIET
     { pop pop pop }
     { ( ) print =only ( files, ) print =only ( scanned, ) print
@@ -374,7 +382,7 @@
 /.setnativefontmapbuilt { % set whether we've been run
   dup type /booleantype eq {
       systemdict exch /.nativefontmapbuilt exch .forceput
-  }
+  } executeonly
   {pop}
   ifelse
 } .bind executeonly odef
@@ -422,7 +430,6 @@
     //true .setnativefontmapbuilt
   } ifelse
 } bind def
-currentdict /.setnativefontmapbuilt .forceundef
 
 % Create the dictionary that registers the .buildfont procedure
 % (called by definefont) for each FontType.
@@ -516,7 +523,7 @@
       if
     }
    if
-   dup .FontDirectory 4 -2 roll { .growput } systemdict /superexec known {//superexec}{1183615869 internaldict /superexec get exec} ifelse	% readonly
+   dup //.FontDirectory 4 -2 roll { .growput } systemdict /superexec known {//superexec}{1183615869 internaldict /superexec get exec} ifelse	% readonly
                 % If the font originated as a resource, register it.
    currentfile .currentresourcefile eq { dup .registerfont } if
    readonly
@@ -526,7 +533,8 @@
 % We use this only for explicitly aliased fonts, not substituted fonts:
 % we think this matches the observed behavior of Adobe interpreters.
 /.aliasfont             % <name> <font> .aliasfont <newFont>
- { .currentglobal 3 1 roll dup .gcheck .setglobal
+ {
+   currentglobal 3 1 roll dup gcheck setglobal
                              % <bool> <name> <font>
    dup length 2 add dict     % <bool> <name> <font> <dict>
    dup 3 -1 roll             % <bool> <name> <dict> <dict> <font>
@@ -541,7 +549,7 @@
                 % whose FontName is a local non-string, if someone passed a
                 % garbage value to findfont.  In this case, just don't
                 % call definefont at all.
-   2 index dup type /stringtype eq exch .gcheck or 1 index .gcheck not or
+    2 index dup type /stringtype eq exch gcheck or 1 index gcheck not or
     { pop                              % <bool> <name> <dict>
       1 index dup type /stringtype eq { cvn } if
                                        % <bool> <name> <dict> <name1>
@@ -566,10 +574,11 @@
                 % Don't bind in definefont, since Level 2 redefines it.
       /definefont .systemvar exec
     }
-    { /findfont cvx {.completefont} .errorexec pop exch pop
+    {
+      /findfont cvx {.completefont} //.errorexec exec pop exch pop
     }
    ifelse
-   exch .setglobal
+   exch setglobal
  } odef         % so findfont will bind it
 
 % Define .loadfontfile for loading a font.  If we recognize Type 1 and/or
@@ -669,10 +678,19 @@
   [(Cn) 4] [(Cond) 4] [(Narrow) 4] [(Pkg) 4] [(Compr) 4]
   [(Serif) 8] [(Sans) -8]
 ] readonly def
+
+/.fontnamestring {              % <fontname> .fontnamestring <string|name>
+  dup type dup /nametype eq {
+    pop .namestring
+  } {
+    /stringtype ne { pop () } if
+  } ifelse
+} bind def
+
 /.fontnameproperties {          % <int> <string|name> .fontnameproperties
                                 %   <int'>
-  .fontnamestring
-  .substituteproperties {
+  //.fontnamestring exec
+  //.substituteproperties {
     2 copy 0 get search {
       pop pop pop dup length 1 sub 1 exch getinterval 3 -1 roll exch {
         dup 0 ge { or } { neg not and } ifelse
@@ -710,13 +728,7 @@
                                 % <other> .nametostring <other>
   dup type /nametype eq { .namestring } if
 } bind def
-/.fontnamestring {              % <fontname> .fontnamestring <string|name>
-  dup type dup /nametype eq {
-    pop .namestring
-  } {
-    /stringtype ne { pop () } if
-  } ifelse
-} bind def
+
 /.substitutefontname {          % <fontname> <properties> .substitutefontname
                                 %   <altname|null>
         % Look for properties and/or a face name in the font name.
@@ -724,7 +736,7 @@
         % base font; otherwise, use the default font.
         % Note that the "substituted" font name may be the same as
         % the requested one; the caller must check this.
-  exch .fontnamestring {
+  exch //.fontnamestring exec {
     defaultfontname /Helvetica-Oblique /Helvetica-Bold /Helvetica-BoldOblique
     /Helvetica-Narrow /Helvetica-Narrow-Oblique
     /Helvetica-Narrow-Bold /Helvetica-Narrow-BoldOblique
@@ -734,12 +746,12 @@
   } 3 1 roll
         % Stack: facelist properties fontname
         % Look for a face name.
-  .substitutefaces {
+  //.substitutefaces {
     2 copy 0 get search {
       pop pop pop
         % Stack: facelist properties fontname [(pattern) family properties]
       dup 2 get 4 -1 roll or 3 1 roll
-      1 get .substitutefamilies exch get
+      1 get //.substitutefamilies exch get
       4 -1 roll pop 3 1 roll
     } {
       pop pop
@@ -748,7 +760,7 @@
   1 index length mod get exec
 } bind def
 /.substitutefont {              % <fontname> .substitutefont <altname>
-  dup 0 exch .fontnameproperties .substitutefontname
+  dup 0 exch //.fontnameproperties exec .substitutefontname
         % Only accept fonts known in the Fontmap.
    Fontmap 1 index known not
    {
@@ -814,7 +826,7 @@
   counttomark 1 sub { .aliasfont } repeat end
                       % <fontname> mark <font>
   exch pop exch pop
-} odef
+} bind odef
 /findfont {
   .findfont
 } bind def
@@ -860,7 +872,7 @@
       } {
         dup .substitutefont
         2 copy eq { pop defaultfontname } if
-        .checkalias
+        //.checkalias exec
         QUIET not {
           SHORTERRORS {
             (%%[) print 1 index =only
@@ -886,8 +898,8 @@
   //null 0 1 FONTPATH length 1 sub {
     FONTPATH 1 index get //null ne { exch pop exit } if pop
   } for dup //null ne {
-    dup 0 eq { .scanfontbegin } if
-    FONTPATH 1 index get .scanfontdir
+    dup 0 eq { //.scanfontbegin exec} if
+    FONTPATH 1 index get //.scanfontdir exec
     FONTPATH exch //null put //true
   } {
     pop //false
@@ -897,11 +909,10 @@
 % scanning of FONTPATH.
 /.dofindfont {   %  mark <fontname> .dofindfont % mark <alias> ... <font>
   .tryfindfont not {
-
                         % We didn't find the font.  If we haven't scanned
                         % all the directories in FONTPATH, scan the next one
                         % now and look for the font again.
-    .scannextfontdir {
+    //.scannextfontdir exec {
                         % Start over with an empty alias list.
       counttomark 1 sub { pop } repeat    % mark <fontname>
       .dofindfont
@@ -927,6 +938,7 @@
         } if
                         % Substitute for the font.  Don't alias.
                         % Same stack as at the beginning of .dofindfont.
+
         $error /SubstituteFont get exec
                          %
                          % igorm: I guess the surrounding code assumes that .stdsubstfont
@@ -935,104 +947,24 @@
                          % used in .dofindfont and through .stdsubstfont
                          % just to represent a simple iteration,
                          % which accumulates the aliases after the mark.
-        .stdsubstfont
+        //.stdsubstfont exec
       } ifelse
     } ifelse
   } if
 } bind def
-% Try to find a font using only the present contents of Fontmap.
-/.tryfindfont {         % <fontname> .tryfindfont <font> true
-                        % <fontname> .tryfindfont false
-  .FontDirectory 1 index .fontknownget
-    {                   % Already loaded
-      exch pop //true
-    }
-    {
-       dup Fontmap exch .knownget
-       { //true //true }
-       {                % Unknown font name.  Look for a file with the
-                        % same name as the requested font.
-         dup .tryloadfont
-         { exch pop //true //false }
-         {
-           % if we can't load by name check the native font map
-           dup .nativeFontmap exch .knownget
-           { //true //true }
-           { //false //false } ifelse
-         } ifelse
-       } ifelse
-
-       {                % Try each element of the Fontmap in turn.
-         pop
-         //false exch   % (in case we exhaust the list)
-                        % Stack: fontname false fontmaplist
-         { exch pop
-           dup type /nametype eq
-            {                   % Font alias
-              .checkalias .tryfindfont exit
-            }
-            { dup dup type dup /arraytype eq exch /packedarraytype eq or exch xcheck and
-               {                % Font with a procedural definition
-                 exec           % The procedure will load the font.
-                                % Check to make sure this really happened.
-                 .FontDirectory 1 index .knownget
-                  { exch pop //true exit }
-                 if
-               }
-               {                % Font file name
-                 //true .loadfontloop { //true exit } if
-               }
-              ifelse
-            }
-           ifelse //false
-         }
-         forall
-                        % Stack: font true -or- fontname false
-         { //true
-         }
-         {                      % None of the Fontmap entries worked.
-                                % Try loading a file with the same name
-                                % as the requested font.
-           .tryloadfont
-         }
-        ifelse
-       }
-      if
-    }
-   ifelse
- } bind def
 
 % any user of .putgstringcopy must use bind and executeonly
 /.putgstringcopy  %   <dict> <name> <string> .putgstringcopy -
 { 2 index gcheck currentglobal
   2 copy eq {
     pop pop .forceput
-  } {
+  } executeonly {
     5 1 roll setglobal
     dup length string copy
     .forceput setglobal
-  } ifelse
+  } executeonly ifelse
 } .bind executeonly odef % must be bound and hidden for .forceput
 
-% Attempt to load a font from a file.
-/.tryloadfont {         % <fontname> .tryloadfont <font> true
-                        % <fontname> .tryloadfont false
-  dup .nametostring
-                % Hack: check for the presence of the resource machinery.
-  /.genericrfn where {
-    pop
-    pop dup .fonttempstring /FontResourceDir getsystemparam .genericrfn
-    {//false .loadfontloop} .internalstopped {//false} if {
-      //true
-    } {
-      dup .nametostring
-      {//true .loadfontloop} .internalstopped {//false} if
-    } ifelse
-  } {
-    {//true .loadfontloop} .internalstopped {//false} if
-  } ifelse
-} bind def
-
 /.loadfontloop {        % <fontname> <filename> <libflag> .loadfontloop
                         %   <font> true
                         % -or-
@@ -1081,11 +1013,11 @@
                 % because it's different depending on language level.
            .currentglobal exch /.setglobal .systemvar exec
                 % Remove the fake definition, if any.
-           .FontDirectory 3 index .forceundef		% readonly
-           1 index (r) file .loadfont .FontDirectory exch
+           //.FontDirectory 3 index .forceundef		% readonly
+           1 index (r) file .loadfont //.FontDirectory exch
            /.setglobal .systemvar exec
-         }
-         { .loadfont .FontDirectory
+         } executeonly
+         { .loadfont //.FontDirectory
          }
         ifelse
                 % Stack: fontname fontfilename fontdirectory
@@ -1102,10 +1034,10 @@
          } if
 
                 % Check to make sure the font was actually loaded.
-        dup 3 index .fontknownget
+         dup 3 index //.fontknownget exec
          { dup /PathLoad 4 index .putgstringcopy
            4 1 roll pop pop pop //true exit
-         } if
+         } executeonly if
 
                 % Maybe the file had a different FontName.
                 % See if we can get a FontName from the file, and if so,
@@ -1113,14 +1045,14 @@
         exch dup      % Stack: origfontname fontdirectory path path
         (r) file .findfontname
          {            % Stack: origfontname fontdirectory path filefontname
-           2 index 1 index .fontknownget
+           2 index 1 index //.fontknownget exec
             {   % Yes.  Stack: origfontname fontdirectory path filefontname fontdict
               dup 4 -1 roll /PathLoad exch .putgstringcopy
                       % Stack: origfontname fontdirectory filefontname fontdict
               3 -1 roll pop
                       % Stack: origfontname filefontname fontdict
-              dup /FontName get dup FontDirectory exch .forceundef
-              GlobalFontDirectory exch .forceundef
+              dup /FontName get dup //.FontDirectory exch .forceundef
+              /GlobalFontDirectory .systemvar exch .forceundef
               dup length dict .copydict dup 3 index /FontName exch put
               2 index exch definefont
               exch
@@ -1134,9 +1066,9 @@
               ifelse  % Stack: origfontname fontdict
               exch pop //true exit
                       % Stack: fontdict
-            }
+            } executeonly
            if pop % Stack: origfontname fontdirectory path
-         }
+         } executeonly
         if pop pop  % Stack: origfontname
 
                 % The font definitely did not load correctly.
@@ -1150,7 +1082,88 @@
 
  } bind executeonly odef % must be bound and hidden for .putgstringcopy
 
-currentdict /.putgstringcopy .undef
+
+% Attempt to load a font from a file.
+/.tryloadfont {         % <fontname> .tryloadfont <font> true
+                        % <fontname> .tryloadfont false
+  dup //.nametostring exec
+                % Hack: check for the presence of the resource machinery.
+  /.genericrfn where {
+    pop
+    pop dup //.fonttempstring /FontResourceDir getsystemparam .genericrfn
+    {//false .loadfontloop} .internalstopped {//false} if {
+      //true
+    } {
+      dup //.nametostring exec
+      {//true .loadfontloop} .internalstopped {//false} if
+    } ifelse
+  } {
+    {//true .loadfontloop} .internalstopped {//false} if
+  } ifelse
+} bind def
+
+% Try to find a font using only the present contents of Fontmap.
+/.tryfindfont {         % <fontname> .tryfindfont <font> true
+                        % <fontname> .tryfindfont false
+  //.FontDirectory 1 index //.fontknownget exec
+    {                   % Already loaded
+      exch pop //true
+    }
+    {
+       dup Fontmap exch .knownget
+       { //true //true }
+       {                % Unknown font name.  Look for a file with the
+                        % same name as the requested font.
+         dup //.tryloadfont exec
+         { exch pop //true //false }
+         {
+           % if we can't load by name check the native font map
+           dup .nativeFontmap exch .knownget
+           { //true //true }
+           { //false //false } ifelse
+         } ifelse
+       } ifelse
+
+       {                % Try each element of the Fontmap in turn.
+         pop
+         //false exch   % (in case we exhaust the list)
+                        % Stack: fontname false fontmaplist
+         { exch pop
+           dup type /nametype eq
+            {                   % Font alias
+              //.checkalias exec
+              .tryfindfont exit
+            }
+            { dup dup type dup /arraytype eq exch /packedarraytype eq or exch xcheck and
+               {                % Font with a procedural definition
+                 exec           % The procedure will load the font.
+                                % Check to make sure this really happened.
+                 //.FontDirectory 1 index .knownget
+                  { exch pop //true exit }
+                 if
+               }
+               {                % Font file name
+                 //true .loadfontloop { //true exit } if
+               }
+              ifelse
+            }
+           ifelse //false
+         }
+         forall
+                        % Stack: font true -or- fontname false
+         { //true
+         }
+         {                      % None of the Fontmap entries worked.
+                                % Try loading a file with the same name
+                                % as the requested font.
+           //.tryloadfont exec
+         }
+        ifelse
+       }
+      if
+    }
+   ifelse
+ } bind def
 
 % Define a procedure to load all known fonts.
 % This isn't likely to be very useful.
@@ -1176,10 +1189,10 @@
       {
         {
           pop dup type /stringtype eq { cvn } if
-          .FontDirectory 1 index known not {
+          //.FontDirectory 1 index known not {
             2 dict dup /FontName 3 index put
             dup /FontType 1 put
-            .FontDirectory 3 1 roll { put } systemdict /superexec known {//superexec}{1183615869 internaldict /superexec get exec} ifelse   % readonly
+            //.FontDirectory 3 1 roll { put } systemdict /superexec known {//superexec}{1183615869 internaldict /superexec get exec} ifelse   % readonly
           } {
             pop
           } ifelse
@@ -1192,9 +1205,9 @@
 /.loadinitialfonts
  { NOFONTMAP not
     { /FONTMAP where
-          { pop [ FONTMAP .pathlist ]
+          { pop [ FONTMAP //.pathlist exec]
              { dup VMDEBUG findlibfile
-                { exch pop .loadFontmap }
+                { exch pop //.loadFontmap exec }
                 { /undefinedfilename signalerror }
                ifelse
              }
@@ -1208,7 +1221,7 @@
                    pop pop
                    defaultfontmap_content { .definefontmap } forall
                  } {
-                   .loadFontmap
+                   //.loadFontmap exec
                  } ifelse
                } {
                  pop pop
@@ -1272,3 +1285,18 @@
  { .makemodifiedfont
    dup /FontName get exch definefont pop
  } bind def
+
+% Undef these, not needed outside this file
+[
+ % /.fonttempstring /.scannextfontdir - are also used in gs_res.ps, so are undefined there
+ % /.fontnameproperties - is used in pdf_font.ps
+ % /.scanfontheaders - used in gs_cff.ps, gs_ttf.ps
+ /.loadfontloop /.tryloadfont /.findfont /.pathlist /.loadFontmap /.lowerstring
+ /.splitfilename /.scanfontdict /.scanfontbegin
+ /.scanfontskip /.scan1fontstring
+ /.scan1fontfirst /.scanfontdir
+ /.setnativefontmapbuilt /.aliasfont
+ /.setloadingfont /.substitutefaces /.substituteproperties /.substitutefamilies
+ /.nametostring /.fontnamestring /.checkalias /.fontknownget /.stdsubstfont
+ /.putgstringcopy
+] {systemdict exch .forceundef} forall
--- ghostscript-9.26/Resource/Init/gs_init.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_init.ps	2019-01-23 18:49:06.345067402 +0000
@@ -54,7 +54,7 @@
    dup /userdict
    currentdict dup 200 .setmaxlength		% userdict
    .forceput			% userdict is local, systemdict is global
- }
+ } executeonly
 if begin
 
 % Define dummy local/global operators if needed.
@@ -299,13 +299,6 @@
   1 index exch .makeoperator def
 } .bind def
 
-% Define a special version of def for storing local objects into global
-% dictionaries.  Like .forceput, this exists only during initialization.
-/.forcedef {		% <key> <value> .forcedef -
-  1 .argindex pop	% check # of args
-  currentdict 3 1 roll .forceput
-} .bind odef
-
 % Define procedures for accessing variables in systemdict and userdict
 % regardless of the contents of the dictionary stack.
 /.systemvar {		% <name> .systemvar <value>
@@ -347,7 +340,7 @@
        }
       ifelse
     } .bind def
-} if
+} executeonly if
 
 %**************** BACKWARD COMPATIBILITY ****************
 /hwsizedict mark /HWSize //null .dicttomark readonly def
@@ -655,7 +648,7 @@
       /ifelse .systemvar
     ] cvx executeonly
   exch .setglobal
-} odef
+} executeonly odef
 systemdict /internaldict dup .makeinternaldict .makeoperator
 .forceput		% proc is local, systemdict is global
 
@@ -1093,7 +1086,7 @@
 
 % Define $error.  This must be in local VM.
 .currentglobal //false .setglobal
-/$error 40 dict .forcedef	% $error is local, systemdict is global
+currentdict /$error 40 dict .forceput	% $error is local, systemdict is global
                 % newerror, errorname, command, errorinfo,
                 % ostack, estack, dstack, recordstacks,
                 % binary, globalmode,
@@ -1112,8 +1105,8 @@
 % Define errordict similarly.  It has one entry per error name,
 %   plus handleerror.  However, some astonishingly badly written PostScript
 %   files require it to have at least one empty slot.
-/errordict ErrorNames length 3 add dict
-.forcedef		% errordict is local, systemdict is global
+currentdict /errordict ErrorNames length 3 add dict
+.forceput		% errordict is local, systemdict is global
 .setglobal		% back to global VM
 %  gserrordict contains all the default error handling methods, but unlike
 %  errordict it is noaccess after creation (also it is in global VM).
@@ -1168,8 +1161,8 @@
     }ifelse
   }forall
   noaccess pop
-  systemdict /.setsafeerrors .forceundef
-  systemdict /.SAFERERRORLIST .forceundef
+  //systemdict /.setsafeerrors .forceundef
+  //systemdict /.SAFERERRORLIST .forceundef
 } bind executeonly odef
 
 SAFERERRORS {.setsafererrors} if
@@ -1273,8 +1266,9 @@
 (END PROCS) VMDEBUG
 
 % Define the font directory.
+currentdict
 /FontDirectory //false .setglobal 100 dict //true .setglobal
-.forcedef		% FontDirectory is local, systemdict is global
+.forceput		% FontDirectory is local, systemdict is global
 
 % Define the encoding dictionary.
 /EncodingDirectory 16 dict def	% enough for Level 2 + PDF standard encodings
@@ -2114,7 +2108,7 @@
 
 /.locksafe {
   .locksafe_userparams
-  systemdict /getenv {pop //false} .forceput
+  //systemdict /getenv {pop //false} .forceput
   % setpagedevice has the side effect of clearing the page, but
   % we will just document that. Using setpagedevice keeps the device
   % properties and pagedevice .LockSafetyParams in agreement even
@@ -2333,7 +2327,6 @@
   //systemdict /UndefinePostScriptOperators get exec
   //systemdict /UndefinePDFOperators get exec
   //systemdict /.forcecopynew .forceundef	% remove temptation
-  //systemdict /.forcedef .forceundef		% ditto
   //systemdict /.forceput .forceundef		% ditto
   //systemdict /.undef .forceundef		    % ditto
   //systemdict /.forceundef .forceundef		% ditto
@@ -2357,7 +2350,7 @@
         % Update the copy of the user parameters.
   mark .currentuserparams counttomark 2 idiv {
     userparams 3 1 roll .forceput	% userparams is read-only
-  } repeat pop
+  } executeonly repeat pop
         % Turn on idiom recognition, if available.
   currentuserparams /IdiomRecognition known {
     /IdiomRecognition //true .definepsuserparam
@@ -2368,15 +2361,15 @@
         % (and, if implemented, context switching).
   .currentglobal //false .setglobal
      mark userparams { } forall .dicttomark readonly
-     /userparams exch .forcedef		% systemdict is read-only
+     currentdict exch /userparams exch .forceput		% systemdict is read-only
   .setglobal
-} if
+} executeonly if
 /.currentsystemparams where {
   pop
         % Remove real system params from pssystemparams.
   mark .currentsystemparams counttomark 2 idiv {
     pop pssystemparams exch .forceundef
-  } repeat pop
+  } executeonly repeat pop
 } if
 
 % Set up AlignToPixels :
@@ -2458,7 +2451,6 @@
 DELAYBIND not {
   systemdict /.bindnow .undef       % We only need this for DELAYBIND
   systemdict /.forcecopynew .undef	% remove temptation
-  systemdict /.forcedef .undef		% ditto
   systemdict /.forceput .undef		% ditto
   systemdict /.forceundef .undef	% ditto
 } if
--- ghostscript-9.26/Resource/Init/gs_lev2.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_lev2.ps	2019-01-23 18:49:06.345067402 +0000
@@ -154,7 +154,8 @@
       % protect top level of parameters that we copied
       dup type dup /arraytype eq exch /stringtype eq or { readonly } if
       /userparams .systemvar 3 1 roll .forceput  % userparams is read-only
-    } {
+    } executeonly
+    {
       pop pop
     } ifelse
   } forall
@@ -224,7 +225,7 @@
          % protect top level parameters that we copied
          dup type dup /arraytype eq exch /stringtype eq or { readonly } if
          //pssystemparams 3 1 roll .forceput	% pssystemparams is read-only
-       }
+       } executeonly
        { pop pop
        }
       ifelse
@@ -303,31 +304,30 @@
     psuserparams exch /.checkFilePermitparams load put
   .setglobal
 
-pssystemparams begin
-  /CurDisplayList 0 .forcedef
-  /CurFormCache 0 .forcedef
-  /CurInputDevice () .forcedef
-  /CurOutlineCache 0 .forcedef
-  /CurOutputDevice () .forcedef
-  /CurPatternCache 0 .forcedef
-  /CurUPathCache 0 .forcedef
-  /CurScreenStorage 0 .forcedef
-  /CurSourceList 0 .forcedef
-  /DoPrintErrors //false .forcedef
-  /JobTimeout 0 .forcedef
-  /LicenseID (LN-001) .forcedef     % bogus
-  /MaxDisplayList 140000 .forcedef
-  /MaxFormCache 100000 .forcedef
-  /MaxImageBuffer 524288 .forcedef
-  /MaxOutlineCache 65000 .forcedef
-  /MaxPatternCache 100000 .forcedef
-  /MaxUPathCache 300000 .forcedef
-  /MaxScreenStorage 84000 .forcedef
-  /MaxSourceList 25000 .forcedef
-  /PrinterName product .forcedef
-  /RamSize 4194304 .forcedef
-  /WaitTimeout 40 .forcedef
-end
+pssystemparams
+dup /CurDisplayList 0 .forceput
+dup /CurFormCache 0 .forceput
+dup /CurInputDevice () .forceput
+dup /CurOutlineCache 0 .forceput
+dup /CurOutputDevice () .forceput
+dup /CurPatternCache 0 .forceput
+dup /CurUPathCache 0 .forceput
+dup /CurScreenStorage 0 .forceput
+dup /CurSourceList 0 .forceput
+dup /DoPrintErrors //false .forceput
+dup /JobTimeout 0 .forceput
+dup /LicenseID (LN-001) .forceput     % bogus
+dup /MaxDisplayList 140000 .forceput
+dup /MaxFormCache 100000 .forceput
+dup /MaxImageBuffer 524288 .forceput
+dup /MaxOutlineCache 65000 .forceput
+dup /MaxPatternCache 100000 .forceput
+dup /MaxUPathCache 300000 .forceput
+dup /MaxScreenStorage 84000 .forceput
+dup /MaxSourceList 25000 .forceput
+dup /PrinterName product .forceput
+dup /RamSize 4194304 .forceput
+    /WaitTimeout 40 .forceput
 
 % Define the procedures for handling comment scanning.  The names
 % %ProcessComment and %ProcessDSCComment are known to the interpreter.
@@ -709,7 +709,7 @@
 /statusdict currentdict def
 
 currentdict end
-/statusdict exch .forcedef	% statusdict is local, systemdict is global
+currentdict exch /statusdict exch .forceput	% statusdict is local, systemdict is global
 
 % The following compatibility operators are in systemdict.  They are
 % defined here, rather than in gs_init.ps, because they require the
@@ -934,7 +934,7 @@
   dup /PaintProc get
   1 index /Implementation known not {
     1 index dup /Implementation //null .forceput readonly pop
-  } if
+  } executeonly if
   exec
 }.bind odef
 
@@ -958,7 +958,7 @@
   dup /PaintProc get
   1 index /Implementation known not {
     1 index dup /Implementation //null .forceput readonly pop
-  } if
+  } executeonly if
   /UNROLLFORMS where {/UNROLLFORMS get}{false}ifelse not
   %% [CTM] <<Form>> PaintProc .beginform -
   {
@@ -1005,7 +1005,7 @@
         %% Form dictioanry using the /Implementation key).
         1 dict dup /FormID 4 -1 roll put
         1 index exch /Implementation exch .forceput readonly pop
-      }
+      } executeonly
       ifelse
     }
     {
--- ghostscript-9.26/Resource/Init/gs_ll3.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_ll3.ps	2019-01-23 18:49:06.346067402 +0000
@@ -521,9 +521,8 @@
 % Define additional user and system parameters.
 /HalftoneMode 0 .definepsuserparam
 /MaxSuperScreen 1016 .definepsuserparam
-pssystemparams begin		% read-only, so use .forcedef
-  /MaxDisplayAndSourceList 160000 .forcedef
-end
+% read-only, so use .forceput
+pssystemparams  /MaxDisplayAndSourceList 160000 .forceput
 
 % Define the IdiomSet resource category.
 { /IdiomSet } {
--- ghostscript-9.26/Resource/Init/gs_pdfwr.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_pdfwr.ps	2019-01-23 18:48:51.000067402 +0000
@@ -650,7 +650,7 @@
             } ifelse
           } bind .makeoperator .forceput
           systemdict /.pdf_hooked_DSC_Creator //true .forceput
-        } if
+        } executeonly if
         pop
       } if
     } {
--- ghostscript-9.26/Resource/Init/gs_res.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_res.ps	2019-01-23 18:52:48.409067402 +0000
@@ -41,10 +41,10 @@
 % However, Ed Taft of Adobe says their interpreters don't implement this
 % either, so we aren't going to worry about it for a while.
 
-currentglobal //false setglobal systemdict begin
-  /localinstancedict 5 dict
-  .forcedef	% localinstancedict is local, systemdict is global
-end //true setglobal
+currentglobal //false setglobal
+  systemdict /localinstancedict 5 dict
+  .forceput	% localinstancedict is local, systemdict is global
+//true setglobal
 /.emptydict 0 dict readonly def
 setglobal
 
@@ -149,10 +149,10 @@
           dup [ exch 0 -1 ] exch
           .Instances 4 2 roll put
                 % Make the Category dictionary read-only.  We will have to
-                % use .forceput / .forcedef later to replace the dummy,
+                % use .forceput / .forceput later to replace the dummy,
                 % empty .Instances dictionary with the real one later.
           readonly
-        } {
+        }{
           /defineresource cvx /typecheck signaloperror
         } ifelse
 } bind executeonly odef
@@ -304,7 +304,8 @@
      dup () ne {
      .file_name_directory_separator concatstrings
     } if
-    2 index exch //false .file_name_combine not {
+    2 index exch //false
+    .file_name_combine not {
       (Error: .default_resource_dir returned ) print exch print ( that can't combine with ) print =
       /.default_resource_dir cvx /configurationerror signalerror
     } if
@@ -317,14 +318,14 @@
 pssystemparams begin
   .default_resource_dir
   /FontResourceDir (Font) .resource_dir_name
-     readonly .forcedef	% pssys'params is r-o
+     readonly currentdict 3 1 roll .forceput	% pssys'params is r-o
   /GenericResourceDir () .resource_dir_name
-     readonly .forcedef	% pssys'params is r-o
+     readonly currentdict 3 1 roll .forceput	% pssys'params is r-o
   pop % .default_resource_dir
   /GenericResourcePathSep
-        .file_name_separator readonly .forcedef		% pssys'params is r-o
-  (%diskFontResourceDir) cvn (/Resource/Font/) readonly .forcedef	% pssys'params is r-o
-  (%diskGenericResourceDir) cvn (/Resource/) readonly .forcedef	% pssys'params is r-o
+        .file_name_separator readonly currentdict 3 1 roll .forceput		% pssys'params is r-o
+  currentdict (%diskFontResourceDir) cvn (/Resource/Font/) readonly .forceput	% pssys'params is r-o
+  currentdict (%diskGenericResourceDir) cvn (/Resource/) readonly .forceput	% pssys'params is r-o
 end
 end
 
@@ -422,9 +423,9 @@
                 .Instances dup //.emptydict eq {
                   pop 3 dict
                         % As noted above, Category dictionaries are read-only,
-                        % so we have to use .forcedef here.
-                  /.Instances 1 index .forcedef	% Category dict is read-only
-                } if
+                        % so we have to use .forceput here.
+                  currentdict /.Instances 2 index .forceput	% Category dict is read-only
+                } executeonly if
               }
               { .LocalInstances dup //.emptydict eq
                  { pop 3 dict localinstancedict Category 2 index put
@@ -441,7 +442,7 @@
            { /defineresource cvx /typecheck signaloperror
            }
         ifelse
-} .bind executeonly .makeoperator		% executeonly to prevent access to .forcedef
+} .bind executeonly .makeoperator		% executeonly to prevent access to .forceput
 /UndefineResource
         {  { dup 2 index .knownget
               { dup 1 get 1 ge
@@ -961,7 +962,7 @@
     dup type /nametype eq { .namestring } if
     dup type /stringtype ne { //false exit } if
                 % Check the resource directory.
-    dup .fonttempstring /FontResourceDir getsystemparam .genericrfn
+    dup //.fonttempstring /FontResourceDir getsystemparam .genericrfn
     status {
       pop pop pop pop //true exit
     } if
@@ -969,7 +970,7 @@
                 % as the font.
     findlibfile { closefile //true exit } if
                 % Scan a FONTPATH directory and try again.
-    .scannextfontdir not { //false exit } if
+    //.scannextfontdir exec not { //false exit } if
   } loop
 } bind def
 
@@ -1008,7 +1009,7 @@
         } ifelse
 } bind executeonly
 /ResourceForAll {
-        { .scannextfontdir not { exit } if } loop
+        { //.scannextfontdir exec not { exit } if } loop
         /Generic /Category findresource /ResourceForAll get exec
 } bind executeonly
 /.ResourceFileStatus {
--- ghostscript-9.26/Resource/Init/gs_setpd.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_setpd.ps	2019-01-23 18:48:51.000067402 +0000
@@ -634,7 +634,7 @@
   SETPDDEBUG { (Rolling back.) = pstack flush } if
   3 index 2 index 3 -1 roll .forceput
   4 index 1 index .knownget
-  { 4 index 3 1 roll .forceput }
+  { 4 index 3 1 roll .forceput } executeonly
   { 3 index exch .undef }
   ifelse
 } bind executeonly odef
--- ghostscript-9.26/Resource/Init/gs_statd.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/gs_statd.ps	2019-01-23 18:49:06.346067402 +0000
@@ -21,10 +21,10 @@
         % We make statusdict a little larger for Level 2 stuff.
         % Note that it must be allocated in local VM.
  .currentglobal //false .setglobal
- /statusdict 91 dict .forcedef		% statusdict is local, sys'dict global
+ currentdict /statusdict 91 dict .forceput		% statusdict is local, sys'dict global
         % To support the Level 2 job control features,
         % serverdict must also be in local VM.
- /serverdict 10 dict .forcedef		% serverdict is local, sys'dict global
+ currentdict /serverdict 10 dict .forceput		% serverdict is local, sys'dict global
  .setglobal
 end
 
--- ghostscript-9.26/Resource/Init/pdf_base.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/pdf_base.ps	2019-01-23 18:48:51.001067402 +0000
@@ -130,26 +130,29 @@
 
 /.pdfexectoken {		% <count> <opdict> <exectoken> .pdfexectoken ?
   PDFDEBUG {
-    pdfdict /PDFSTEPcount known not { pdfdict /PDFSTEPcount 1 .forceput } if
+    pdfdict /PDFSTEPcount known not { pdfdict /PDFSTEPcount 1 .forceput } executeonly if
     PDFSTEP {
       pdfdict /PDFtokencount 2 copy .knownget { 1 add } { 1 } ifelse .forceput
       PDFSTEPcount 1 gt {
         pdfdict /PDFSTEPcount PDFSTEPcount 1 sub .forceput
-      } {
+      } executeonly
+      {
         dup ==only
         (    step # ) print PDFtokencount =only
         ( ? ) print flush 1 //false .outputpage
         (%stdin) (r) file 255 string readline {
           token {
             exch pop pdfdict /PDFSTEPcount 3 -1 roll .forceput
-          } {
+          } executeonly
+          {
             pdfdict /PDFSTEPcount 1 .forceput
-          } ifelse % token
+          } executeonly ifelse % token
         } {
           pop /PDFSTEP //false def	 % EOF on stdin
         } ifelse % readline
       } ifelse % PDFSTEPcount > 1
-    } {
+    } executeonly
+    {
       dup ==only () = flush
     } ifelse % PDFSTEP
   } if % PDFDEBUG
--- ghostscript-9.26/Resource/Init/pdf_draw.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/pdf_draw.ps	2019-01-23 18:48:51.001067402 +0000
@@ -1118,14 +1118,14 @@
           pdfdict /.Qqwarning_issued //true .forceput
           .setglobal
           pdfformaterror
-        } ifelse
+        } executeonly ifelse
       }
       {
         currentglobal pdfdict gcheck .setglobal
         pdfdict /.Qqwarning_issued //true .forceput
         .setglobal
         pdfformaterror
-      } ifelse
+      } executeonly ifelse
       end
     } ifelse
   } loop
@@ -1141,14 +1141,14 @@
         pdfdict /.Qqwarning_issued //true .forceput
         .setglobal
         pdfformaterror
-      } ifelse
+      } executeonly ifelse
     }
     {
       currentglobal pdfdict gcheck .setglobal
       pdfdict /.Qqwarning_issued //true .forceput
       .setglobal
       pdfformaterror
-    } ifelse
+    } executeonly ifelse
   } if
   pop
 
@@ -2350,9 +2350,10 @@
 /IncrementAppearanceNumber {
   pdfdict /AppearanceNumber .knownget {
     1 add pdfdict /AppearanceNumber 3 -1 roll .forceput
-  }{
+  } executeonly
+  {
     pdfdict /AppearanceNumber 0 .forceput
-  } ifelse
+  } executeonly ifelse
 }bind executeonly odef
 
 /MakeAppearanceName {
@@ -2510,7 +2511,8 @@
     %% want to preserve it.
     pdfdict /.PreservePDFForm false .forceput
     /q cvx /execform cvx 5 -2 roll
-  }{
+  } executeonly
+  {
     /q cvx /PDFexecform cvx 5 -2 roll
   } ifelse
 
--- ghostscript-9.26/Resource/Init/pdf_font.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/pdf_font.ps	2019-01-23 18:48:51.001067402 +0000
@@ -714,7 +714,7 @@
     pop pop pop
     currentdict /.stackdepth .forceundef
     currentdict /.dstackdepth .forceundef
-  }
+  } executeonly
   {pop pop pop}
   ifelse
 
@@ -1232,7 +1232,7 @@
                 (\n   **** Warning: Type 3 glyph has unbalanced q/Q operators \(too many q's\)\n               Output may be incorrect.\n)
                 pdfformatwarning
                 pdfdict /.Qqwarning_issued //true .forceput
-              } if
+              } executeonly if
               Q
             } repeat
             Q
@@ -2016,7 +2016,7 @@
               /CIDFallBack /CIDFont findresource
             } if
             exit
-          } if
+          } executeonly if
         } if
       } if
 
--- ghostscript-9.26/Resource/Init/pdf_main.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/pdf_main.ps	2019-01-23 18:48:51.002067402 +0000
@@ -2701,14 +2701,14 @@
           pdfdict /.Qqwarning_issued //true .forceput
           .setglobal
           pdfformaterror
-        } ifelse
+        } executeonly ifelse
       }
       {
         currentglobal pdfdict gcheck .setglobal
         pdfdict /.Qqwarning_issued //true .forceput
         .setglobal
         pdfformaterror
-      } ifelse
+      } executeonly ifelse
     } if
   } if
   pop
--- ghostscript-9.26/Resource/Init/pdf_ops.ps	2018-11-20 10:08:19.000000000 +0000
+++ gs-patched/Resource/Init/pdf_ops.ps	2019-01-23 18:48:51.002067402 +0000
@@ -184,14 +184,14 @@
         pdfdict /.Qqwarning_issued //true .forceput
         .setglobal
         pdfformaterror
-      } ifelse
+      } executeonly ifelse
     }
     {
       currentglobal pdfdict gcheck .setglobal
       pdfdict /.Qqwarning_issued //true .forceput
       .setglobal
       pdfformaterror
-    } ifelse
+    } executeonly ifelse
   } if
 } bind executeonly odef
 
@@ -439,7 +439,8 @@
   dup type /booleantype eq {
     .currentSMask type /dicttype eq {
       .currentSMask /Processed 2 index .forceput
-    } {
+  } executeonly
+  {
       .setSMask
   }ifelse
   }{
