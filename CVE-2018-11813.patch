Changes in rdtarga.c picked from v9d development version at
https://jpegclub.org/reference/reference-sources/

rdtarga.c: use read_byte(), with EOF check, instead of getc()
in read_*_pixel().
Thank to Chijin Zhou for cjpeg potential vulnerability report.
---
 jpeg/rdtarga.c | 34 ++++++++++++----------------------
 1 file changed, 12 insertions(+), 22 deletions(-)

diff --git a/jpeg/rdtarga.c b/jpeg/rdtarga.c
index b3a7251..c72ad73 100644
--- a/jpeg/rdtarga.c
+++ b/jpeg/rdtarga.c
@@ -2,7 +2,7 @@
  * rdtarga.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
- * Modified 2017 by Guido Vollbeding.
+ * Modified 2017-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -29,11 +29,10 @@
 typedef unsigned char U_CHAR;
 #define UCH(x)	((int) (x))
 #else /* !HAVE_UNSIGNED_CHAR */
-#ifdef CHAR_IS_UNSIGNED
 typedef char U_CHAR;
+#ifdef CHAR_IS_UNSIGNED
 #define UCH(x)	((int) (x))
 #else
-typedef char U_CHAR;
 #define UCH(x)	((int) (x) & 0xFF)
 #endif
 #endif /* HAVE_UNSIGNED_CHAR */
@@ -125,20 +124,17 @@ METHODDEF(void)
 read_non_rle_pixel (tga_source_ptr sinfo)
 /* Read one Targa pixel from the input file; no RLE expansion */
 {
-  register FILE *infile = sinfo->pub.input_file;
   register int i;
 
   for (i = 0; i < sinfo->pixel_size; i++) {
-    sinfo->tga_pixel[i] = (U_CHAR) getc(infile);
+    sinfo->tga_pixel[i] = (U_CHAR) read_byte(sinfo);
   }
 }
 
-
 METHODDEF(void)
 read_rle_pixel (tga_source_ptr sinfo)
 /* Read one Targa pixel from the input file, expanding RLE data as needed */
 {
-  register FILE *infile = sinfo->pub.input_file;
   register int i;
 
   /* Duplicate previously read pixel? */
@@ -160,7 +156,7 @@ read_rle_pixel (tga_source_ptr sinfo)
 
   /* Read next pixel */
   for (i = 0; i < sinfo->pixel_size; i++) {
-    sinfo->tga_pixel[i] = (U_CHAR) getc(infile);
+    sinfo->tga_pixel[i] = (U_CHAR) read_byte(sinfo);
   }
 }
 
@@ -171,7 +167,6 @@ read_rle_pixel (tga_source_ptr sinfo)
  * We provide several different versions depending on input file format.
  */
 
-
 METHODDEF(JDIMENSION)
 get_8bit_gray_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
 /* This version is for reading 8-bit grayscale pixels */
@@ -288,9 +283,8 @@ get_memory_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   source_row = cinfo->image_height - source->current_row - 1;
 
   /* Fetch that row from virtual array */
-  source->pub.buffer = (*cinfo->mem->access_virt_sarray)
-    ((j_common_ptr) cinfo, source->whole_image,
-     source_row, (JDIMENSION) 1, FALSE);
+  source->pub.buffer = (*cinfo->mem->access_virt_sarray) ((j_common_ptr) cinfo,
+    source->whole_image, source_row, (JDIMENSION) 1, FALSE);
 
   source->current_row++;
   return 1;
@@ -409,7 +403,6 @@ start_input_tga (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
       break;
     default:
       ERREXIT(cinfo, JERR_TGA_BADPARMS);
-      break;
     }
     TRACEMS2(cinfo, 1, JTRC_TGA, width, height);
     break;
@@ -424,7 +417,6 @@ start_input_tga (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
     break;
   default:
     ERREXIT(cinfo, JERR_TGA_BADPARMS);
-    break;
   }
 
   if (is_bottom_up) {
@@ -442,9 +434,8 @@ start_input_tga (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   } else {
     /* Don't need a virtual array, but do need a one-row input buffer. */
     source->whole_image = NULL;
-    source->pub.buffer = (*cinfo->mem->alloc_sarray)
-      ((j_common_ptr) cinfo, JPOOL_IMAGE,
-       (JDIMENSION) width * components, (JDIMENSION) 1);
+    source->pub.buffer = (*cinfo->mem->alloc_sarray) ((j_common_ptr) cinfo,
+      JPOOL_IMAGE, (JDIMENSION) width * components, (JDIMENSION) 1);
     source->pub.buffer_height = 1;
     source->pub.get_pixel_rows = source->get_pixel_rows;
   }
@@ -456,8 +447,8 @@ start_input_tga (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
     if (maplen > 256 || GET_2B(3) != 0)
       ERREXIT(cinfo, JERR_TGA_BADCMAP);
     /* Allocate space to store the colormap */
-    source->colormap = (*cinfo->mem->alloc_sarray)
-      ((j_common_ptr) cinfo, JPOOL_IMAGE, (JDIMENSION) maplen, (JDIMENSION) 3);
+    source->colormap = (*cinfo->mem->alloc_sarray) ((j_common_ptr) cinfo,
+      JPOOL_IMAGE, (JDIMENSION) maplen, (JDIMENSION) 3);
     source->cmap_length = (int) maplen;
     /* and read it from the file */
     read_colormap(source, (int) maplen, UCH(targaheader[7]));
@@ -496,9 +487,8 @@ jinit_read_targa (j_compress_ptr cinfo)
   tga_source_ptr source;
 
   /* Create module interface object */
-  source = (tga_source_ptr)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				  SIZEOF(tga_source_struct));
+  source = (tga_source_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(tga_source_struct));
   source->cinfo = cinfo;	/* make back link for subroutines */
   /* Fill in method ptrs, except get_pixel_rows which start_input sets */
   source->pub.start_input = start_input_tga;
-- 
2.22.0

